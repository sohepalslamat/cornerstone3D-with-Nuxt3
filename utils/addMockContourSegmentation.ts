import { utilities as csUtils } from '@cornerstonejs/core';
import { annotation, utilities as cstUtils } from '@cornerstonejs/tools';

export function addMockContourSegmentation({
  segmentationId,
  contours,
  viewport,
}: any) {
  contours = Array.isArray(contours) ? contours : [contours];
  contours.forEach((contour: { segmentIndex?: 1 | undefined; radius?: 100 | undefined; resolution?: 100 | undefined; centerOffset?: number[] | undefined; }) => {
    const {
      segmentIndex = 1,
      radius = 100,
      resolution = 6,
      centerOffset = [0, 0],
    } = contour;

    // get the circle annotation that would draw if we pick the center
    // as the circle center and the radius as the distance from the center
    // to the edge of the viewport

    const centerInCanvas = [
      viewport.canvas.width / 2 + centerOffset[0],
      viewport.canvas.height / 2 + centerOffset[1],
    ];
    const radiusInCanvas = radius;

    const polyline = Array.from(Array(resolution).keys()).map((i) => {
      const angle = (i * 2 * Math.PI) / resolution;
      const x = centerInCanvas[0] + radiusInCanvas * Math.cos(angle);
      const y = centerInCanvas[1] + radiusInCanvas * Math.sin(angle);
      console.log(x,y)
      const world = viewport.canvasToWorld([
        x / window?.devicePixelRatio || 1,
        y / window?.devicePixelRatio || 1,
      ]);

      return world;
    });
    console.log(polyline)

    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
    const camera = viewport.getCamera();
    const contourSegmentationAnnotation = {
      annotationUID: csUtils.uuidv4(),
      data: {
        contour: {
          closed: true,
          polyline,
        },
        segmentation: {
          segmentationId,
          segmentIndex,
        },
        handles: {},
      },
      handles: {},
      highlighted: false,
      autoGenerated: false,
      invalidated: false,
      isLocked: false,
      isVisible: true,
      metadata: {
        referencedImageId: viewport.getCurrentImageId(),
        toolName: 'PlanarFreehandContourSegmentationTool',
        FrameOfReferenceUID: FrameOfReferenceUID,
        viewPlaneNormal: camera.viewPlaneNormal,
      },
    };

    const annotationGroupSelector = viewport.element;

    annotation.state.addAnnotation(
      contourSegmentationAnnotation,
      annotationGroupSelector
    );

    cstUtils.contourSegmentation.addContourSegmentationAnnotation(
      contourSegmentationAnnotation
    );

    cstUtils.triggerAnnotationRenderForViewportIds(
      viewport.getRenderingEngine(),
      [viewport.id]
    );
  });
}

export function addRLEFreehandSegmentation({
  segmentationId,
  rleMask,
  viewport,
}: any) {
  // const points = parseRLEMask(rleMask);
  // const worldPoints = points.map(point => {
  //   const pixelIndex = point; // Adjust based on how you access pixel data
  //   console.log(point)
  //   const pixelCoords = [pixelIndex % viewport.canvas.width, Math.floor(pixelIndex / viewport.canvas.width)];
  //   return viewport.canvasToWorld(pixelCoords);
  // });
  // const points = rleToCoordinates(rleMask, 409362);
  const worldPoints = (rleMask as any[]).map(point => {
    const pixelIndex = point; // Adjust based on how you access pixel data
    const pixelCoords = [pixelIndex.x, pixelIndex.y];
    return viewport.canvasToWorld(pixelCoords);
  });


  console.log(worldPoints)
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  const camera = viewport.getCamera();
  const contourSegmentationAnnotation = {
    annotationUID: csUtils.uuidv4(),
    data: {
      contour: {
        closed: false,
        polyline: worldPoints,
      },
      segmentation: {
        segmentationId,
        segmentIndex: 1,
      },
      handles: {},
    },
    handles: {},
    highlighted: false,
    autoGenerated: false,
    invalidated: false,
    isLocked: false,
    isVisible: true,
    metadata: {
      referencedImageId: viewport.getCurrentImageId(),
      toolName: 'PlanarFreehandContourSegmentationTool',
      FrameOfReferenceUID: FrameOfReferenceUID,
      viewPlaneNormal: camera.viewPlaneNormal,
    },
  };

  const annotationGroupSelector = viewport.element;

  annotation.state.addAnnotation(
    contourSegmentationAnnotation,
    annotationGroupSelector
  );

  cstUtils.contourSegmentation.addContourSegmentationAnnotation(
    contourSegmentationAnnotation
  );

  cstUtils.triggerAnnotationRenderForViewportIds(
    viewport.getRenderingEngine(),
    [viewport.id]
  );
}

function parseRLEMask(rleMask: string, maxPoints = 10) {
  const data = rleMask.split(' ').map(Number);
  const points = [];

  for (let i = 0; i < data.length; i += 2) {
    const start = data[i];
    const length = data[i + 1];

    for (let j = 0; j < length; j++) {
      if (points.length >= maxPoints) {
        break; // Stop adding points if we reach the limit
      }
      points.push(start + j);
    }
    if (points.length >= maxPoints) {
      break; // Stop processing if we reach the limit
    }
  }

  return points;
}

function rleToCoordinates(rle:string, width:number) {
  const coordinates = [];
  const rleArray = rle.split(' ').map(Number);

  for (let i = 0; i < rleArray.length; i += 2) {
      const start = rleArray[i];
      const length = rleArray[i + 1];

      // Calculate the x and y coordinates
      const y = Math.floor(start / width);
      const x = start % width;

      // Generate points for the run
      for (let j = 0; j < length; j++) {
          coordinates.push({ x: x + j, y: y });
      }
  }

  return coordinates;
}
